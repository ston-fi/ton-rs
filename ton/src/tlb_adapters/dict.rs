mod data_builder;
mod data_parser;
mod dict_key_adapters;
mod dict_val_adapters;
mod label_type;
mod leading_bit_utils;
mod tlb_hash_map;
mod tlb_hash_map_e;

pub use dict_key_adapters::*;
pub use dict_val_adapters::*;
pub use tlb_hash_map::*;
pub use tlb_hash_map_e::*;

#[cfg(test)]
mod tests {
    use crate::tlb_adapters::{DictKeyAdapterInt, DictValAdapterTLB, TLBHashMap};
    use num_bigint::{BigInt, BigUint};
    use std::collections::HashMap;
    use ton_lib_core::cell::{CellBuilder, CellParser, TonCell};
    use ton_lib_core::errors::TonCoreError;
    use ton_lib_core::traits::tlb::TLB;
    use ton_lib_core::types::tlb_core::adapters::ConstLen;
    use ton_lib_core::TLB;

    #[derive(Clone, Debug, PartialEq, TLB)]
    pub struct DictionaryTickInfo {
        #[tlb(bits_len = 256)]
        pub liquidity_gross: BigUint,
        #[tlb(bits_len = 128)]
        pub liquidity_net: BigInt,
        #[tlb(bits_len = 256)]
        pub outer_fee_growth_token_0: BigUint,
        #[tlb(bits_len = 256)]
        pub outer_fee_growth_token_1: BigUint,
    }

    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TicksDictionary {
        pub ticks: HashMap<i32, DictionaryTickInfo>, // it's not HashMapE, there is no "presenting" bit in cell_data
    }

    impl TLB for TicksDictionary {
        fn read_definition(parser: &mut CellParser) -> Result<Self, TonCoreError> {
            if parser.refs_left() == 0 {
                return Ok(Default::default());
            }
            let dict_cell = parser.read_next_ref()?;
            let adapter = TLBHashMap::<DictKeyAdapterInt<_>, DictValAdapterTLB<_>>::new(24);
            Ok(TicksDictionary {
                ticks: adapter.read(&mut dict_cell.parser())?,
            })
        }

        fn write_definition(&self, builder: &mut CellBuilder) -> Result<(), TonCoreError> {
            if self.ticks.is_empty() {
                return Ok(());
            }
            let mut dict_builder = TonCell::builder();
            let adapter = TLBHashMap::<DictKeyAdapterInt<_>, DictValAdapterTLB<_>>::new(24);
            adapter.write(&mut dict_builder, &self.ticks)?;
            builder.write_ref(dict_builder.build()?)
        }
    }

    // ticks_dictionary from one of tonco pools
    #[test]
    fn test_dict_signed_key() -> anyhow::Result<()> {
        let ticks_dict = TicksDictionary::from_boc_hex("b5ee9c7201023a01000db7000100010201200203020270040502027706070202c7080900e7a7626d000000000000000000000000000000000000000000000000000000000f857ad67ffffffffffffffffffffffff07a8529c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000e7a69d93000000000000000000000000000000000000000000000000000000000f857ad64000000000000000000000000f857ad640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200202e80a0b0201200c0d00e5ac1a0000000000000000000000000000000000000000000000000000001203af60cb7fffffffffffffffffffffedfc509f35000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000e4aa24000000000000000000000000000000000000000000000000000000000006c57b0000000000000000000000000006c57b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000201200e0f020120101102012012130201201415020120161702012018190201201a1b0201201c1d00e3a610000000000000000000000000000000000000000000000000000000480d879ce40000000000000000000000480d879ce40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100e3a01000000000000000000000000000000000000000000000000000000000001b15efffffffffffffffffffffffffffe4ea14000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020201201e1f020120202100e3a2200000000000000000000000000000000000000000000000000000002d7e5b80a400000000000000000000002d7e5b80a40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200e1d00000000000000000000000000000000000000000000000000000000f27e01ae800000000000000000000000f27e01ae80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000102012022230201202425020120262700e3a2c000000000000000000000000000000000000000000000000000000019c31a8bdfffffffffffffffffffffffe63ce5742400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002020120282900e3bec0000000000000000000000000000000000000000000000000000009b51d9fb9a00000000000000000000009b51d9fb9a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080201202a2b0201202c2d0201202e2f00e3be80000000000000000000000000000000000000000000000000000002dcbd1b24800000000000000000000002dcbd1b248000000000000000000000000000000000001791e93a58fca8dc21d6e38806e3800000000000000000000000000000000000185d0edd691e0aec204488dd6c66a8020120303102012032330201203435020120363700e3b8400000000000000000000000000000000000000000000000000000116c11b939ffffffffffffffffffffffee93ee46c61000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008020120383900e3bdc0000000000000000000000000000000000000000000000000000000000297bf9ffffffffffffffffffffffffffd6840700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800e3b5000000000000000000000000000000000000000000000000000000010b4aa453c000000000000000000000010b4aa453c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000e3b4800000000000000000000000000000000000000000000000000000007f32da37e000000000000000000000007f32da37e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000e3b40000000000000000000000000000000000000000000000000000000000052f7f20000000000000000000000000052f7f200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000e3b3800000000000000000000000000000000000000000000000000000007f46389c7fffffffffffffffffffffff80e0842ca00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000e3b300000000000000000000000000000000000000000000000000000002296dd0c9a00000000000000000000002296dd0c9a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000e3b280000000000000000000000000000000000000000000000000000000ce18d45ee00000000000000000000000ce18d45ee00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000e3b48000000000000000000000000000000000000000000000000000000000f632e840000000000000000000000000f632e840000000000000000000000000000000000072bb8b9a825829a67d15b3e16e656000000000000000000000000000000000007708386b39fa9601d0685a847ecd7000e3b4000000000000000000000000000000000000000000000000000000db723a59444000000000000000000000db723a5944400000000000000000000000000000000001d5435ff8920f2c96e420fc0e227a800000000000000000000000000000000001f53a3872e74acfeea634e3e317605000e3b380000000000000000000000000000000000000000000000000000000009a9741c00000000000000000000000009a9741c00000000000000000000000000000000000f78bf54c5a8820d862bbcba0556e200000000000000000000000000000000001029d0d750e0d471ca2b4cac011663000e3b30000000000000000000000000000000000000000000000000000000000849b1c7fffffffffffffffffffffffff7b64e3a00000000000000000000000000000000003a1311a688e075018391fd8b8d8a2000000000000000000000000000000000003fdfe6b44a1fdd31433dc87433ff6f000e3b280000000000000000000000000000000000000000000000000000005b97a36491ffffffffffffffffffffffa4685c9b700000000000000000000000000000000000481de9e8e8d7091507afc9414bb00c00000000000000000000000000000000004fee0766ebd1f45d61c5c6ad40730d000e3b200000000000000000000000000000000000000000000000000000000f353f6085fffffffffffffffffffffff0cac09f7c00000000000000000000000000000000000282722963048d21742893138c2e6c000000000000000000000000000000000002b6435f22fc59f4ede5135415935f000e3b1800000000000000000000000000000000000000000000000000000b89a16e6d07fffffffffffffffffffff4765e9192fa0000000000000000000000000000000000012144bb30b282528bccfd21efc95e00000000000000000000000000000000000139c5a19c43ed4159dcbf57d76795000e3b10000000000000000000000000000000000000000000000000000000000363ab3ffffffffffffffffffffffffffc9c54c20000000000000000000000000000000000001b7e02b966450b641501813d19cc0000000000000000000000000000000000001de91fa2352e7e02e4d0d5804eb1000e3b50000000000000000000000000000000000000000000000000000000178b0311c3ffffffffffffffffffffffe874fcee3e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000e3b48000000000000000000000000000000000000000000000000000001692365f79bfffffffffffffffffffffe96dc9a0866000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010")?;
        assert_eq!(ticks_dict.ticks.len(), 29);

        let parsed_back = TicksDictionary::from_boc(ticks_dict.to_boc()?)?;
        assert_eq!(ticks_dict, parsed_back);
        Ok(())
    }
}
